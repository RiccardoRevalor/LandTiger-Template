


ARM Macro Assembler    Page 1 


    1 00000000         ;PRESERVE8
    2 00000000         ;THUMB
    3 00000000         
    4 00000000         ;AREA input_data, READONLY, ALIGN=4
    5 00000000         ;LTORG       ; Inserisce il literal pool qui
    6 00000000         ;ALIGN 2
    7 00000000         ;DATA_IN   DCB  0x0A, 0x01, 0x13, 0x02, 0x04, 0x06, 0x0F
                       , 0x0A ; Dati definiti nel literal pool
    8 00000000         ;ALIGN 2
    9 00000000         ;N     DCD 8
   10 00000000         ;ALIGN 2
   11 00000000         
   12 00000000         ;AREA output_data, READWRITE, ALIGN=4
   13 00000000         ;BEST_3   DCB 0x0, 0x0, 0x0
   14 00000000         ;ALIGN 2
   15 00000000         
   16 00000000         ;EXPORT DATA_IN
   17 00000000         ;EXPORT N
   18 00000000         ;EXPORT BEST_3 
   19 00000000         ;NOTA BENE, LA AREA READONLY NON � ASSOLUTAMENTE MODIF
                       ICALE E RISCRIVIBILE
   20 00000000                 AREA             asm_functions, CODE, READONLY
   21 00000000         
   22 00000000                 EXPORT           asm_funct
   23 00000000         asm_funct
                               FUNCTION
   24 00000000         
   25 00000000         ;RO = address of VETT
   26 00000000         ;R1 = VAL
   27 00000000         ;R2 = N
   28 00000000         
   29 00000000         ; save current SP for a faster access 
   30 00000000         ; to parameters in the stack
   31 00000000 46EC            MOV              r12, sp
   32 00000002         ; save volatile registers
   33 00000002 E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
   34 00000006         
   35 00000006         ;STMFD sp!,{R0-R3}
   36 00000006         ;MOV R1,R0 ; ho bisogno di VETT address in R1
   37 00000006         ;MOV R0,R2 ; bsort ha bisogno di N in R0
   38 00000006         ;BL bsort
   39 00000006         ;LDMFD sp!,{R0-R3}
   40 00000006         ;; extract argument 4 and 5 into R4 and R5
   41 00000006         ;LDR   r4, [r12]
   42 00000006         ;LDR   r5, [r12,#4]
   43 00000006         ;LDR   r6, [r12,#8]
   44 00000006         
   45 00000006         ; setup a value for R0 to return
   46 00000006         ; MOV   r0, r1
   47 00000006         ; MOV   r1, r8
   48 00000006         ; restore volatile registers
   49 00000006 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
   50 0000000A                 ENDFUNC
   51 0000000A         
   52 0000000A                 EXPORT           bsort
   53 0000000A         bsort   PROC
   54 0000000A         ; Bubble sort an array of 32bit integers in place
   55 0000000A         ; R0 Numero di elementi nel vettore
   56 0000000A         ; R1 Vettore da ordinare



ARM Macro Assembler    Page 2 


   57 0000000A 46EC            MOV              r12, sp
   58 0000000C E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
   59 00000010         
   60 00000010         
   61 00000010         ; ALGORITMO 
   62 00000010 4605            MOV              R5, R0
   63 00000012 F04F 0B01       MOV              R11, #1
   64 00000016         
   65 00000016 1E40            SUBS             R0, R0, #1
   66 00000018 D01A            BEQ              exit
   67 0000001A         
   68 0000001A         while
   69 0000001A F1BB 0F01       CMP              R11, #1
   70 0000001E D117            BNE              exit
   71 00000020         
   72 00000020 4605            MOV              R5, R0
   73 00000022 F04F 0600       MOV              R6, #0
   74 00000026 F04F 0701       MOV              R7, #1
   75 0000002A F04F 0B00       MOV              R11, #0
   76 0000002E         
   77 0000002E         for
   78 0000002E 5D8C            LDRB             R4, [R1, R6]
   79 00000030         ;LDR R4, [R1, R6, LSL#2] ;se il vettore � in word
   80 00000030 F811 8007       LDRB             R8, [R1, R7]
   81 00000034         ;LDR R8, [R1, R7, LSL#2] ;se il vettore � in word
   82 00000034 45A0            CMP              R8, R4
   83 00000036         ;CMP R4, R8 ;ordine Cresente
   84 00000036 BFC2 F04F 
              0B01             MOVGT            R11, #1
   85 0000003C F801 8006       STRBGT           R8, [R1, R6]
   86 00000040         ;STRGT R8, [R1, R6, LSL#2]
   87 00000040 55CC            STRBGT           R4, [R1, R7]
   88 00000042         ;STRGT R4, [R1, R7, LSL#2]
   89 00000042         
   90 00000042 F106 0601       ADD              R6, R6, #1
   91 00000046 F107 0701       ADD              R7, R7, #1
   92 0000004A         
   93 0000004A 1E6D            SUBS             R5, R5, #1
   94 0000004C D1EF            BNE              for
   95 0000004E D0E4            BEQ              while
   96 00000050         
   97 00000050         exit
   98 00000050         ; restore volatile registers
   99 00000050 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  100 00000054                 ENDP
  101 00000054         
  102 00000054         
  103 00000054         
  104 00000054         ; Salvataggio del risultato:
  105 00000054         ;Dopo che __aeabi_fdiv ha eseguito la divisione, il risu
                       ltato viene restituito in R0. Ora salviamo questo risult
                       ato (che � il valore di ritorno della nostra funzione)
                        in R4:
  106 00000054         
  107 00000054         
  108 00000054         ;MOV R4, R0  ; Salva il risultato della divisione (in R0
                       ) in R4
  109 00000054         ; dei registri:
  110 00000054         ;Prima di restituire il controllo alla funzione chiamant



ARM Macro Assembler    Page 3 


                       e, dobbiamo ripristinare i registri che avevamo salvato 
                       all'inizio della funzione. In questo caso, ripristiniamo
                        prima R0-R3 (registri che potrebbero essere stati modif
                       icati durante la funzione) e poi R4-R7 (i registri che a
                       bbiamo utilizzato direttamente per la divisione):
  111 00000054         
  112 00000054         ;LDMFD sp!,{r4-r8,r10-r11,pc}  ; Ripristina i registri
  113 00000054         ;Restituzione del risultato:
  114 00000054         ;Ora dobbiamo restituire il valore di ritorno dalla funz
                       ione (R4, che contiene il risultato della divisione) nel
                        registro R0, poich� questo � il registro in cui la 
                       funzione chiamante si aspetta di trovare il risultato. S
                       uccessivamente, ripristiniamo il registro del link (LR),
                        che contiene l'indirizzo di ritorno, e salviamo lo stat
                       o del programma:
  115 00000054         
  116 00000054         
  117 00000054         ;MOV R0, R4  ; Carica il valore di ritorno (risultato) i
                       n R0
  118 00000054         ;LDMFD sp!,{r4-r8,r10-r11,pc}  ; Ripristina i registri e
                        torna alla funzione chiamante
  119 00000054         ;Come funziona il ritorno in R0
  120 00000054         ;La convenzione ARM vuole che il valore di ritorno di un
                       a funzione venga passato nel registro R0. Quando chiami 
                       la funzione my_division da C con:
  121 00000054         
  122 00000054         
  123 00000054         ;pi = my_division((float*)&area, &radiusPowerOf2);
  124 00000054         ;questa chiamata si traduce in un'istruzione che passa g
                       li indirizzi di area e radiusPowerOf2 nei registri R0 e 
                       R1 rispettivamente.
  125 00000054         
  126 00000054         ;La funzione my_division esegue la divisione, e quando a
                       rriva alla fine, il risultato della divisione viene cari
                       cato nel registro R0, che � il registro di ritorno. Qu
                       indi, quando la funzione ritorna, il valore di R0 viene 
                       utilizzato dalla funzione chiamante (in questo caso il c
                       odice C che ha chiamato my_division).
  127 00000054         
  128 00000054                 IMPORT           __aeabi_fdiv ;Importa la funzio
                                                            ne di divisione in 
                                                            virgola mobile
  129 00000054                 EXPORT           my_division ;Esporta la funzion
                                                            e
  130 00000054         my_division
                               FUNCTION
  131 00000054         ; Salva i registri che saranno usati
  132 00000054 46EC            MOV              r12, sp
  133 00000056 E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  134 0000005A         
  135 0000005A         ; Carica i valori di area e radius^2
  136 0000005A 6804            LDR              R4, [R0]    ; Carica il valore 
                                                            di 'area' (passato 
                                                            tramite R0) in R4
  137 0000005C 680D            LDR              R5, [R1]    ; Carica il valore 
                                                            di 'radius^2' (pass
                                                            ato tramite R1) in 
                                                            R5
  138 0000005E         



ARM Macro Assembler    Page 4 


  139 0000005E         ; Carica i valori nei registri R0 e R1 per la divisione
  140 0000005E 4620            MOV              R0, R4      ; Carica 'area' in 
                                                            R0 (argomento per _
                                                            _aeabi_fdiv)
  141 00000060 4629            MOV              R1, R5      ; Carica 'radius^2'
                                                             in R1 (argomento p
                                                            er __aeabi_fdiv)
  142 00000062         
  143 00000062         ; Chiama la funzione __aeabi_fdiv per eseguire la divisi
                       one
  144 00000062 F7FF FFFE       BL               __aeabi_fdiv ; __aeabi_fdiv(a, 
                                                            b) -> R0 = a / b AC
                                                            CETTA SOLO FLOAT!!!
                                                             AREA DEVE ESSERE D
                                                            ICHIARATO FLOAT!!!
  145 00000066         
  146 00000066         ; Il risultato della divisione � ora in R0
  147 00000066         ; (Potresti voler memorizzare questo risultato o restitu
                       irlo)
  148 00000066         ;MOV  R4, R0 ; Salva il risultato della divisione (in R0
                       ) in R4 cosi da non avere problemi con lo stack  e le po
                       p che non me lo farebbero salvare corretamente
  149 00000066         ; Rimuove i registri dalla pila e ritorna
  150 00000066         ;POP  {R0-R3}
  151 00000066         ;MOV  R0, R4  ;Carica il valore di ritorno (risultato) i
                       n R0
  152 00000066 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  153 0000006A                 ENDFUNC
  154 0000006A         
  155 0000006A                 EXPORT           call_svc
  156 0000006A         call_svc
                               FUNCTION
  157 0000006A         ; save current SP for a faster access 
  158 0000006A         ; to parameters in the stack
  159 0000006A         ;MOV   r12, sp
  160 0000006A         ; save volatile registers
  161 0000006A 46EC            MOV              r12, sp
  162 0000006C E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  163 00000070 4668            MOV              R0,R13      ;PASS INTO THE SVC 
                                                            HANDLER ADDRESS OF 
                                                            PSP   
  164 00000072         ; your code
  165 00000072 DF15            SVC              0x15
  166 00000074 E7FE            B                .
  167 00000076 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  168 0000007A         ; restore volatile registers
  169 0000007A         ;LDMFD sp!,{pc}
  170 0000007A                 ENDFUNC
  171 0000007A         
  172 0000007A                 EXPORT           count_leading_zero
  173 0000007A         count_leading_zero
                               FUNCTION
  174 0000007A 46EC            MOV              r12, sp
  175 0000007C         ; ro is value to count leading zero  
  176 0000007C E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  177 00000080         
  178 00000080 FAB0 F080       CLZ              R0,R0
  179 00000084         
  180 00000084 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}



ARM Macro Assembler    Page 5 


  181 00000088                 ENDFUNC
  182 00000088         
  183 00000088                 EXPORT           count_bit1
  184 00000088         count_bit1
                               FUNCTION
  185 00000088         ; in R0 dovr� esserci il numero in cui bisogna contare
                        gli 1
  186 00000088 46EC            MOV              r12, sp
  187 0000008A E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  188 0000008E         
  189 0000008E F04F 0120       MOV              R1, #32     ; numero di cifre d
                                                            el numero (BINARIO)
                                                            
  190 00000092 F04F 0200       MOV              R2, #0      ; variabile che con
                                                            terra il numero di 
                                                            1
  191 00000096         
  192 00000096         loopCountBit1
  193 00000096 0040            LSLS             R0, R0, #1
  194 00000098 BF28 1C52       ADDCS            R2, R2, #1
  195 0000009C         
  196 0000009C 1E49            SUBS             R1, R1, #1
  197 0000009E D1FA            BNE              loopCountBit1
  198 000000A0         
  199 000000A0 4610            MOV              R0, R2
  200 000000A2         
  201 000000A2 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  202 000000A6                 ENDFUNC
  203 000000A6         
  204 000000A6                 EXPORT           get_max
  205 000000A6         get_max FUNCTION
  206 000000A6         ;R0=Vett
  207 000000A6         ;R1=dim
  208 000000A6         
  209 000000A6 46EC            MOV              r12, sp
  210 000000A8 E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  211 000000AC         
  212 000000AC F850 6B04       LDR              R6, [R0], #4 ; Carica il primo 
                                                            elemento dell'array
                                                             in R6 (massimo ini
                                                            ziale)
  213 000000B0 1E49            SUBS             R1, R1, #1  ; Decrementa la dim
                                                            ensione (R1 = dim -
                                                             1)
  214 000000B2 DD06            BLE              exitMax     ; Se R1 <= 0, salta
                                                             direttamente all'u
                                                            scita
  215 000000B4         
  216 000000B4         loopMax
  217 000000B4 F850 4B04       LDR              R4, [R0], #4 ; Carica l'element
                                                            o corrente in R4 e 
                                                            avanza il puntatore
                                                             R0
  218 000000B8 42B4            CMP              R4, R6      ; Confronta l'eleme
                                                            nto corrente (R4) c
                                                            on il massimo attua
                                                            le (R6)
  219 000000BA BFC8 4626       MOVGT            R6, R4      ; Se R4 > R6, aggio
                                                            rna il massimo in R



ARM Macro Assembler    Page 6 


                                                            6
  220 000000BE 1E49            SUBS             R1, R1, #1  ; Decrementa il con
                                                            tatore R1
  221 000000C0 DCF8            BGT              loopMax     ; Ripeti finch� R
                                                            1 > 0
  222 000000C2         
  223 000000C2         exitMax
  224 000000C2 4630            MOV              R0, R6      ; Salva il massimo 
                                                            trovato in R0 (regi
                                                            stro di ritorno)
  225 000000C4         
  226 000000C4 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  227 000000C8                 ENDFUNC
  228 000000C8         
  229 000000C8                 EXPORT           get_min
  230 000000C8         get_min FUNCTION
  231 000000C8         ;R0=Vett (puntatore all'array)
  232 000000C8         ;R1=dim  (dimensione dell'array)
  233 000000C8         
  234 000000C8 46EC            MOV              r12, sp
  235 000000CA E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr} ; Salva 
                                                            i registri callee-s
                                                            aved nello stack
  236 000000CE         
  237 000000CE F850 6B04       LDR              R6, [R0], #4 ; Carica il primo 
                                                            elemento dell'array
                                                             in R6 (minimo iniz
                                                            iale)
  238 000000D2 1E49            SUBS             R1, R1, #1  ; Decrementa la dim
                                                            ensione (R1 = dim -
                                                             1)
  239 000000D4 DD06            BLE              exitMin     ; Se R1 <= 0, salta
                                                             direttamente all'u
                                                            scita
  240 000000D6         
  241 000000D6         loopMin
  242 000000D6 F850 4B04       LDR              R4, [R0], #4 ; Carica l'element
                                                            o corrente in R4 e 
                                                            avanza il puntatore
                                                             R0
  243 000000DA 42B4            CMP              R4, R6      ; Confronta l'eleme
                                                            nto corrente (R4) c
                                                            on il minimo attual
                                                            e (R6)
  244 000000DC BFB8 4626       MOVLT            R6, R4      ; Se R4 < R6, aggio
                                                            rna il minimo in R6
                                                            
  245 000000E0 1E49            SUBS             R1, R1, #1  ; Decrementa il con
                                                            tatore R1
  246 000000E2 DCF8            BGT              loopMin     ; Ripeti finch� R
                                                            1 > 0
  247 000000E4         
  248 000000E4         exitMin
  249 000000E4 4630            MOV              R0, R6      ; Salva il minimo t
                                                            rovato in R0 (regis
                                                            tro di ritorno)
  250 000000E6         
  251 000000E6 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc} ; Ripris
                                                            tina i registri e r



ARM Macro Assembler    Page 7 


                                                            itorna
  252 000000EA                 ENDFUNC
  253 000000EA         
  254 000000EA                 EXPORT           is_monotonic_increasing
  255 000000EA         is_monotonic_increasing
                               FUNCTION
  256 000000EA         ; R0 = Vett (puntatore all'array)
  257 000000EA         ; R1 = dim (dimensione dell'array)
  258 000000EA         
  259 000000EA 46EC            MOV              r12, sp
  260 000000EC E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr} ; Salva 
                                                            i registri callee-s
                                                            aved nello stack
  261 000000F0         
  262 000000F0 2901            CMP              R1, #1      ; Verifica se il ve
                                                            ttore ha al massimo
                                                             un elemento
  263 000000F2 DD0B            BLE              exitTrue    ; Un vettore con 0 
                                                            o 1 elemento � mo
                                                            notono crescente
  264 000000F4         
  265 000000F4 F850 4B04       LDR              R4, [R0], #4 ; Carica il primo 
                                                            elemento dell'array
                                                             in R4
  266 000000F8 1E49            SUBS             R1, R1, #1  ; Decrementa la dim
                                                            ensione (R1 = dim -
                                                             1)
  267 000000FA         
  268 000000FA         loopCheck
  269 000000FA F850 5B04       LDR              R5, [R0], #4 ; Carica l'element
                                                            o successivo in R5
  270 000000FE 42AC            CMP              R4, R5      ; Confronta l'eleme
                                                            nto precedente (R4)
                                                             con l'elemento cor
                                                            rente (R5)
  271 00000100 BFC8 2000       MOVGT            R0, #0      ; Se R4 > R5, il ve
                                                            ttore non � monot
                                                            ono crescente
  272 00000104 DC05            BGT              exitFalse   ; Esce con "false" 
                                                            (0) se non � mono
                                                            tono crescente
  273 00000106 462C            MOV              R4, R5      ; Aggiorna R4 con l
                                                            'elemento corrente
  274 00000108 1E49            SUBS             R1, R1, #1  ; Decrementa il con
                                                            tatore R1
  275 0000010A DCF6            BGT              loopCheck   ; Continua finch�
                                                             ci sono elementi d
                                                            a verificare
  276 0000010C         
  277 0000010C         exitTrue
  278 0000010C F04F 0001       MOV              R0, #1      ; Imposta il risult
                                                            ato a "true" (1)
  279 00000110 E001            B                endFunction_is_monotonic_increa
sing 
                                                            ; Salta alla fine
  280 00000112         
  281 00000112         exitFalse
  282 00000112 F04F 0000       MOV              R0, #0      ; Imposta il risult
                                                            ato a "false" (0)



ARM Macro Assembler    Page 8 


  283 00000116         
  284 00000116         endFunction_is_monotonic_increasing
  285 00000116 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc} ; Ripris
                                                            tina i registri e r
                                                            itorna
  286 0000011A                 ENDFUNC
  287 0000011A         
  288 0000011A                 EXPORT           module
  289 0000011A         module  FUNCTION
  290 0000011A         
  291 0000011A         ;RO = e1
  292 0000011A         ;R1 = e2
  293 0000011A         
  294 0000011A         ; save current SP for a faster access 
  295 0000011A         ; to parameters in the stack
  296 0000011A 46EC            MOV              r12, sp
  297 0000011C         ; save volatile registers
  298 0000011C E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  299 00000120         
  300 00000120         ;STMFD sp!,{R0-R3}
  301 00000120         ;MOV R1,R0 ; ho bisogno di VETT address in R1
  302 00000120         ;MOV R0,R2 ; bsort ha bisogno di N in R0
  303 00000120         ;BL bsort
  304 00000120         ;LDMFD sp!,{R0-R3}
  305 00000120         ;; extract argument 4 and 5 into R4 and R5
  306 00000120         ;LDR   r4, [r12]
  307 00000120         ;LDR   r5, [r12,#4]
  308 00000120         ;LDR   r6, [r12,#8]
  309 00000120         ; Calcolo del quoziente (divisione intera)
  310 00000120 FBB0 F3F1       UDIV             r3, r0, r1  ; r3 = a / b (divis
                                                            ione intera)
  311 00000124         
  312 00000124         ; Calcolo di q * b
  313 00000124 FB03 F301       MUL              r3, r3, r1  ; r3 = (a / b) * b
  314 00000128         
  315 00000128         ; Calcolo del resto
  316 00000128 EBA0 0003       SUB              r0, r0, r3  ;r0 = a - (q * b)
  317 0000012C         
  318 0000012C         ; Ora r0 contiene il risultato di a % b
  319 0000012C         
  320 0000012C         ; setup a value for R0 to return
  321 0000012C         ; MOV   r1, r8
  322 0000012C         ; restore volatile registers
  323 0000012C E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  324 00000130                 ENDFUNC
  325 00000130         
  326 00000130                 EXPORT           abs_value
  327 00000130         abs_value
                               FUNCTION
  328 00000130         
  329 00000130         ;RO = op1
  330 00000130         ;R1 = op22
  331 00000130         
  332 00000130         ; save current SP for a faster access 
  333 00000130         ; to parameters in the stack
  334 00000130 46EC            MOV              r12, sp
  335 00000132         ; save volatile registers
  336 00000132 E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  337 00000136         



ARM Macro Assembler    Page 9 


  338 00000136         ;STMFD sp!,{R0-R3}
  339 00000136         ;MOV R1,R0 ; ho bisogno di VETT address in R1
  340 00000136         ;MOV R0,R2 ; bsort ha bisogno di N in R0
  341 00000136         ;BL bsort
  342 00000136         ;LDMFD sp!,{R0-R3}
  343 00000136         ;; extract argument 4 and 5 into R4 and R5
  344 00000136         ;LDR   r4, [r12]
  345 00000136         ;LDR   r5, [r12,#4]
  346 00000136         ;LDR   r6, [r12,#8]
  347 00000136         
  348 00000136 4288            CMP              R0,R1
  349 00000138         ;r0<=r1
  350 00000138 BFB4 EBC0 
              0001             RSBLT            R0,R0,R1    ;r1-r0
  351 0000013E         ;r0>r1
  352 0000013E 1A40            SUBGE            R0,R0,R1    ;r0-r1
  353 00000140         
  354 00000140         ; setup a value for R0 to return
  355 00000140         ; MOV   r1, r8
  356 00000140         ; restore volatile registers
  357 00000140 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  358 00000144         
  359 00000144                 ENDFUNC
  360 00000144         
  361 00000144                 EXPORT           Prime_or_Not
  362 00000144         Prime_or_Not
                               FUNCTION
  363 00000144         ; save current SP for a faster access 
  364 00000144         ; to parameters in the stack
  365 00000144 46EC            MOV              r12, sp
  366 00000146         ; save volatile registers
  367 00000146 E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  368 0000014A F04F 000F       MOV              R0,#15      ;Number which you w
                                                            ant to test
  369 0000014E 2801            CMP              R0,#01      ;Comparing with 01
  370 00000150 D011            BEQ              PRIME       ;If equal declare d
                                                            irectly as prime
  371 00000152 2802            CMP              R0,#02      ;Compare with 02
  372 00000154 D00F            BEQ              PRIME       ;If equal declare d
                                                            irectly as prime
  373 00000156 4601            MOV              R1,R0       ;Copy test number i
                                                            n R1
  374 00000158 F04F 0202       MOV              R2,#02      ;Initial divider
  375 0000015C         UP
  376 0000015C F7FF FFFE       BL               DIVISION    ;Call for division 
                                                            sub-function
  377 00000160 F1B8 0F00       CMP              R8,#00      ;Compare remainder 
                                                            with 0
  378 00000164 D004            BEQ              NOTPRIME    ;If equal then its 
                                                            not prime
  379 00000166 F102 0201       ADD              R2,R2,#01   ;If not increment d
                                                            ivider and check
  380 0000016A 428A            CMP              R2,R1       ;Compare divider wi
                                                            th test number
  381 0000016C D003            BEQ              PRIME       ;All possible numbe
                                                            rs are done means I
                                                            t's prime
  382 0000016E E7F5            B                UP          ;If not repeat unti
                                                            l end



ARM Macro Assembler    Page 10 


  383 00000170         NOTPRIME
  384 00000170 F04F 3311       LDR              R3,=0x11111111 ;Declaring test 
                                                            number is not prime
                                                            
  385 00000174         ; B STOP                   ;Jumping to infinite looping
  386 00000174 E002            B                exitPrime
  387 00000176         PRIME
  388 00000176 F04F 33FF       LDR              R3,=0xFFFFFFFF ;Declaring test 
                                                            number is prime num
                                                            ber
  389 0000017A         ; STOP B STOP               ;Infinite looping
  390 0000017A E7FF            B                exitPrime
  391 0000017C         exitPrime
  392 0000017C E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  393 00000180                 ENDFUNC
  394 00000180         
  395 00000180                 EXPORT           DIVISION    ;Function for divis
                                                            ion operation
  396 00000180         DIVISION
                               FUNCTION
  397 00000180         ; save current SP for a faster access 
  398 00000180         ; to parameters in the stack
  399 00000180 46EC            MOV              r12, sp
  400 00000182         ; save volatile registers
  401 00000182 E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  402 00000186 4680            MOV              R8,R0       ;Copy of data from 
                                                            main function
  403 00000188 4691            MOV              R9,R2       ;Copy of divider fr
                                                            om main function
  404 0000018A         LOOP_DIVISION
  405 0000018A EBA8 0809       SUB              R8,R8,R9    ;Successive subtrac
                                                            tion for division
  406 0000018E F10A 0A01       ADD              R10,R10,#01 ;Counter for holdin
                                                            g the result of div
                                                            ision
  407 00000192 45C8            CMP              R8,R9       ;Compares for non-z
                                                            ero result
  408 00000194 D5F9            BPL              LOOP_DIVISION ;Repeats the loop
                                                             if subtraction is 
                                                            still needed
  409 00000196         
  410 00000196 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  411 0000019A                 ENDFUNC
  412 0000019A         
  413 0000019A                 EXPORT           next_state
  414 0000019A         next_state
                               FUNCTION
  415 0000019A         ; save current SP for a faster access 
  416 0000019A         ; to parameters in the stack
  417 0000019A 46EC            MOV              r12, sp
  418 0000019C         ; save volatile registers
  419 0000019C E92D 4DF0       STMFD            sp!,{r4-r8,r10-r11,lr}
  420 000001A0         
  421 000001A0         ; your code
  422 000001A0         ; r0 = current_state 
  423 000001A0         ; r1 = taps
  424 000001A0         ; r2 = address of output_bit variable
  425 000001A0         
  426 000001A0         ;compute the output bit



ARM Macro Assembler    Page 11 


  427 000001A0 F000 0401       AND              R4,R0,#1    ;and between curren
                                                            t state and 1 to co
                                                            mpute outputbit
  428 000001A4 6014            STR              R4,[R2]     ;store the result o
                                                            f and into the addr
                                                            ess of output_bit
  429 000001A6         
  430 000001A6         ; prevRes is initialted to 0
  431 000001A6 F04F 0500       MOV              R5, #0
  432 000001AA         
  433 000001AA 4606            MOV              R6,R0       ; current state in 
                                                            r6
  434 000001AC 460F            MOV              R7,R1       ; taps in r7
  435 000001AE         
  436 000001AE F04F 0800       MOV              R8,#0       ;N 
  437 000001B2 F04F 0B01       MOV              R11,#1
  438 000001B6         ;The input bit is computed using the current value of th
                       e taps.
  439 000001B6         
  440 000001B6         loopNextState
  441 000001B6 F1B8 0F08       CMP              R8,#8
  442 000001BA D20D            BHS              exitLoopNextState
  443 000001BC EA17 0F0B       TST              R7,R11      ;vedo se il bit i e
                                                            simo in taps è un 
                                                            0 o un 1
  444 000001C0         ;if z==0 i am in taps bit
  445 000001C0 BF1C F006 
              0A01             ANDNE            R10,R6,#1
  446 000001C6 EA85 050A       EORNE            R5,R5,R10
  447 000001CA EA4F 0757       LSR              R7,R7,#1
  448 000001CE EA4F 0656       LSR              R6,R6,#1
  449 000001D2 F108 0801       ADD              R8,R8,#1
  450 000001D6 E7EE            B                loopNextState
  451 000001D8         
  452 000001D8         
  453 000001D8         exitLoopNextState
  454 000001D8         
  455 000001D8         ;R5 IS INPUT
  456 000001D8         
  457 000001D8 EA4F 0050       LSR              R0,R0,#1    ;The state is shift
                                                            ed right by one pos
                                                            ition
  458 000001DC         
  459 000001DC EA4F 15C5       LSL              R5,R5,#7
  460 000001E0 EA80 0005       EOR              R0,R0,R5
  461 000001E4         
  462 000001E4         
  463 000001E4         
  464 000001E4         ; restore volatile registers
  465 000001E4 E8BD 8DF0       LDMFD            sp!,{r4-r8,r10-r11,pc}
  466 000001E8                 ENDFUNC
  467 000001E8         
  468 000001E8                 EXPORT           value_is_in_a_range
  469 000001E8         value_is_in_a_range
                               FUNCTION
  470 000001E8         
  471 000001E8         ; R0 = VALUE
  472 000001E8         ; R1 = MIN
  473 000001E8         ; R2 = MAX



ARM Macro Assembler    Page 12 


  474 000001E8         ; R0 returns:
  475 000001E8         ;   - 1 if MIN <= VALUE <= MAX
  476 000001E8         ;   - 0 otherwise
  477 000001E8         
  478 000001E8         ; Save current SP for faster access to parameters in the
                        stack
  479 000001E8 46EC            MOV              r12, sp
  480 000001EA         ; Save volatile registers
  481 000001EA E92D 4DF0       STMFD            sp!, {r4-r8, r10-r11, lr}
  482 000001EE         
  483 000001EE         ; Compare VALUE with MIN
  484 000001EE 4288            CMP              R0, R1
  485 000001F0 D304            BLO              outOfRange  ; If VALUE < MIN, b
                                                            ranch to outOfRange
                                                            
  486 000001F2         
  487 000001F2         ; Compare VALUE with MAX
  488 000001F2 4290            CMP              R0, R2
  489 000001F4 D802            BHI              outOfRange  ; If VALUE > MAX, b
                                                            ranch to outOfRange
                                                            
  490 000001F6         
  491 000001F6         ; If VALUE is within the range
  492 000001F6 F04F 0001       MOV              R0, #1      ; Set R0 to 1 (true
                                                            )
  493 000001FA E001            B                exitFuncV   ; Branch to exit
  494 000001FC         
  495 000001FC         outOfRange
  496 000001FC F04F 0000       MOV              R0, #0      ; Set R0 to 0 (fals
                                                            e)
  497 00000200         
  498 00000200         exitFuncV
  499 00000200         ; Restore volatile registers
  500 00000200 E8BD 8DF0       LDMFD            sp!, {r4-r8, r10-r11, pc}
  501 00000204         
  502 00000204                 ENDFUNC
  503 00000204         
  504 00000204         ;TODO: array sum
  505 00000204         
  506 00000204         ;TODO: array average
  507 00000204         
  508 00000204                 END
Command Line: --debug --xref --diag_suppress=9931,A1950W --cpu=Cortex-M3 --depe
nd=.\objects\asm_functs.d -o.\objects\asm_functs.o -I.\Source\button_EXINT -I.\
Source\CMSIS_core -I.\Source\joystick -I.\Source\led -I.\Source\RIT -I.\Source\
timer -I.\Source -I.\RTE\_SW_Debug -IC:\Users\candd\AppData\Local\Arm\Packs\ARM
\CMSIS\6.1.0\CMSIS\Core\Include -IC:\Users\candd\AppData\Local\Arm\Packs\Keil\L
PC1700_DFP\2.7.1\Device\Include --predefine="__EVAL SETA 1" --predefine="__UVIS
ION_VERSION SETA 541" --predefine="LPC175x_6x SETA 1" --predefine="_RTE_ SETA 1
" --list=.\listings\asm_functs.lst Source\ASM\ASM_functs.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

DIVISION 00000180

Symbol: DIVISION
   Definitions
      At line 396 in file Source\ASM\ASM_functs.s
   Uses
      At line 376 in file Source\ASM\ASM_functs.s
      At line 395 in file Source\ASM\ASM_functs.s

LOOP_DIVISION 0000018A

Symbol: LOOP_DIVISION
   Definitions
      At line 404 in file Source\ASM\ASM_functs.s
   Uses
      At line 408 in file Source\ASM\ASM_functs.s
Comment: LOOP_DIVISION used once
NOTPRIME 00000170

Symbol: NOTPRIME
   Definitions
      At line 383 in file Source\ASM\ASM_functs.s
   Uses
      At line 378 in file Source\ASM\ASM_functs.s
Comment: NOTPRIME used once
PRIME 00000176

Symbol: PRIME
   Definitions
      At line 387 in file Source\ASM\ASM_functs.s
   Uses
      At line 370 in file Source\ASM\ASM_functs.s
      At line 372 in file Source\ASM\ASM_functs.s
      At line 381 in file Source\ASM\ASM_functs.s

Prime_or_Not 00000144

Symbol: Prime_or_Not
   Definitions
      At line 362 in file Source\ASM\ASM_functs.s
   Uses
      At line 361 in file Source\ASM\ASM_functs.s
Comment: Prime_or_Not used once
UP 0000015C

Symbol: UP
   Definitions
      At line 375 in file Source\ASM\ASM_functs.s
   Uses
      At line 382 in file Source\ASM\ASM_functs.s
Comment: UP used once
abs_value 00000130

Symbol: abs_value
   Definitions
      At line 327 in file Source\ASM\ASM_functs.s
   Uses
      At line 326 in file Source\ASM\ASM_functs.s
Comment: abs_value used once



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

asm_funct 00000000

Symbol: asm_funct
   Definitions
      At line 23 in file Source\ASM\ASM_functs.s
   Uses
      At line 22 in file Source\ASM\ASM_functs.s
Comment: asm_funct used once
asm_functions 00000000

Symbol: asm_functions
   Definitions
      At line 20 in file Source\ASM\ASM_functs.s
   Uses
      None
Comment: asm_functions unused
bsort 0000000A

Symbol: bsort
   Definitions
      At line 53 in file Source\ASM\ASM_functs.s
   Uses
      At line 52 in file Source\ASM\ASM_functs.s
Comment: bsort used once
call_svc 0000006A

Symbol: call_svc
   Definitions
      At line 156 in file Source\ASM\ASM_functs.s
   Uses
      At line 155 in file Source\ASM\ASM_functs.s
Comment: call_svc used once
count_bit1 00000088

Symbol: count_bit1
   Definitions
      At line 184 in file Source\ASM\ASM_functs.s
   Uses
      At line 183 in file Source\ASM\ASM_functs.s
Comment: count_bit1 used once
count_leading_zero 0000007A

Symbol: count_leading_zero
   Definitions
      At line 173 in file Source\ASM\ASM_functs.s
   Uses
      At line 172 in file Source\ASM\ASM_functs.s
Comment: count_leading_zero used once
endFunction_is_monotonic_increasing 00000116

Symbol: endFunction_is_monotonic_increasing
   Definitions
      At line 284 in file Source\ASM\ASM_functs.s
   Uses
      At line 279 in file Source\ASM\ASM_functs.s
Comment: endFunction_is_monotonic_increasing used once
exit 00000050

Symbol: exit



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 97 in file Source\ASM\ASM_functs.s
   Uses
      At line 66 in file Source\ASM\ASM_functs.s
      At line 70 in file Source\ASM\ASM_functs.s

exitFalse 00000112

Symbol: exitFalse
   Definitions
      At line 281 in file Source\ASM\ASM_functs.s
   Uses
      At line 272 in file Source\ASM\ASM_functs.s
Comment: exitFalse used once
exitFuncV 00000200

Symbol: exitFuncV
   Definitions
      At line 498 in file Source\ASM\ASM_functs.s
   Uses
      At line 493 in file Source\ASM\ASM_functs.s
Comment: exitFuncV used once
exitLoopNextState 000001D8

Symbol: exitLoopNextState
   Definitions
      At line 453 in file Source\ASM\ASM_functs.s
   Uses
      At line 442 in file Source\ASM\ASM_functs.s
Comment: exitLoopNextState used once
exitMax 000000C2

Symbol: exitMax
   Definitions
      At line 223 in file Source\ASM\ASM_functs.s
   Uses
      At line 214 in file Source\ASM\ASM_functs.s
Comment: exitMax used once
exitMin 000000E4

Symbol: exitMin
   Definitions
      At line 248 in file Source\ASM\ASM_functs.s
   Uses
      At line 239 in file Source\ASM\ASM_functs.s
Comment: exitMin used once
exitPrime 0000017C

Symbol: exitPrime
   Definitions
      At line 391 in file Source\ASM\ASM_functs.s
   Uses
      At line 386 in file Source\ASM\ASM_functs.s
      At line 390 in file Source\ASM\ASM_functs.s

exitTrue 0000010C

Symbol: exitTrue
   Definitions



ARM Macro Assembler    Page 4 Alphabetic symbol ordering
Relocatable symbols

      At line 277 in file Source\ASM\ASM_functs.s
   Uses
      At line 263 in file Source\ASM\ASM_functs.s
Comment: exitTrue used once
for 0000002E

Symbol: for
   Definitions
      At line 77 in file Source\ASM\ASM_functs.s
   Uses
      At line 94 in file Source\ASM\ASM_functs.s
Comment: for used once
get_max 000000A6

Symbol: get_max
   Definitions
      At line 205 in file Source\ASM\ASM_functs.s
   Uses
      At line 204 in file Source\ASM\ASM_functs.s
Comment: get_max used once
get_min 000000C8

Symbol: get_min
   Definitions
      At line 230 in file Source\ASM\ASM_functs.s
   Uses
      At line 229 in file Source\ASM\ASM_functs.s
Comment: get_min used once
is_monotonic_increasing 000000EA

Symbol: is_monotonic_increasing
   Definitions
      At line 255 in file Source\ASM\ASM_functs.s
   Uses
      At line 254 in file Source\ASM\ASM_functs.s
Comment: is_monotonic_increasing used once
loopCheck 000000FA

Symbol: loopCheck
   Definitions
      At line 268 in file Source\ASM\ASM_functs.s
   Uses
      At line 275 in file Source\ASM\ASM_functs.s
Comment: loopCheck used once
loopCountBit1 00000096

Symbol: loopCountBit1
   Definitions
      At line 192 in file Source\ASM\ASM_functs.s
   Uses
      At line 197 in file Source\ASM\ASM_functs.s
Comment: loopCountBit1 used once
loopMax 000000B4

Symbol: loopMax
   Definitions
      At line 216 in file Source\ASM\ASM_functs.s
   Uses
      At line 221 in file Source\ASM\ASM_functs.s



ARM Macro Assembler    Page 5 Alphabetic symbol ordering
Relocatable symbols

Comment: loopMax used once
loopMin 000000D6

Symbol: loopMin
   Definitions
      At line 241 in file Source\ASM\ASM_functs.s
   Uses
      At line 246 in file Source\ASM\ASM_functs.s
Comment: loopMin used once
loopNextState 000001B6

Symbol: loopNextState
   Definitions
      At line 440 in file Source\ASM\ASM_functs.s
   Uses
      At line 450 in file Source\ASM\ASM_functs.s
Comment: loopNextState used once
module 0000011A

Symbol: module
   Definitions
      At line 289 in file Source\ASM\ASM_functs.s
   Uses
      At line 288 in file Source\ASM\ASM_functs.s
Comment: module used once
my_division 00000054

Symbol: my_division
   Definitions
      At line 130 in file Source\ASM\ASM_functs.s
   Uses
      At line 129 in file Source\ASM\ASM_functs.s
Comment: my_division used once
next_state 0000019A

Symbol: next_state
   Definitions
      At line 414 in file Source\ASM\ASM_functs.s
   Uses
      At line 413 in file Source\ASM\ASM_functs.s
Comment: next_state used once
outOfRange 000001FC

Symbol: outOfRange
   Definitions
      At line 495 in file Source\ASM\ASM_functs.s
   Uses
      At line 485 in file Source\ASM\ASM_functs.s
      At line 489 in file Source\ASM\ASM_functs.s

value_is_in_a_range 000001E8

Symbol: value_is_in_a_range
   Definitions
      At line 469 in file Source\ASM\ASM_functs.s
   Uses
      At line 468 in file Source\ASM\ASM_functs.s
Comment: value_is_in_a_range used once
while 0000001A



ARM Macro Assembler    Page 6 Alphabetic symbol ordering
Relocatable symbols


Symbol: while
   Definitions
      At line 68 in file Source\ASM\ASM_functs.s
   Uses
      At line 95 in file Source\ASM\ASM_functs.s
Comment: while used once
37 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
External symbols

__aeabi_fdiv 00000000

Symbol: __aeabi_fdiv
   Definitions
      At line 128 in file Source\ASM\ASM_functs.s
   Uses
      At line 144 in file Source\ASM\ASM_functs.s
Comment: __aeabi_fdiv used once
1 symbol
372 symbols in table
